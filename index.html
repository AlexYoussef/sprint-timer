<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>üê±‚ö° Sprint Timer</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body { height: 100%; width: 100%; }
  body {
    background: #0a0a0a;
    color: #e0e0e0;
    font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    min-height: 100dvh;
    overflow: hidden;
    padding: clamp(0.5rem, 2vw, 2rem);
  }
  .container {
    text-align: center;
    width: 100%;
    max-width: min(600px, 95vw);
    padding: clamp(0.5rem, 2vw, 2rem);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }
  .header {
    font-size: clamp(0.6rem, 2.5vmin, 1.2rem);
    color: #666;
    margin-bottom: clamp(0.2rem, 1vmin, 0.5rem);
    letter-spacing: 0.2em;
    text-transform: uppercase;
  }
  .task {
    font-size: clamp(0.6rem, 2vmin, 1rem);
    color: #888;
    margin-bottom: clamp(0.5rem, 2vmin, 1.5rem);
    font-style: italic;
    word-break: break-word;
  }
  .clock {
    font-size: clamp(2rem, 18vmin, 7rem);
    font-weight: 200;
    letter-spacing: 0.05em;
    margin: clamp(0.2rem, 1vmin, 0.5rem) 0;
    transition: color 0.5s;
    line-height: 1.1;
  }
  .clock.warning { color: #f59e0b; }
  .clock.danger { color: #ef4444; animation: pulse 1s infinite; }
  .clock.done { color: #22c55e; }
  .clock.running { color: #e0e0e0; }
  .clock.waiting { color: #333; }
  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
  }
  .progress-bar {
    width: 100%;
    height: clamp(2px, 0.5vmin, 4px);
    background: #1a1a1a;
    border-radius: 2px;
    margin: clamp(0.3rem, 1vmin, 1rem) 0;
    overflow: hidden;
  }
  .progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #22c55e, #f59e0b, #ef4444);
    border-radius: 2px;
    transition: width 1s linear;
  }
  .status {
    font-size: clamp(0.55rem, 2vmin, 1rem);
    color: #555;
    margin-top: clamp(0.2rem, 0.5vmin, 0.5rem);
  }
  .sprint-label {
    display: inline-block;
    background: #1a1a1a;
    border: 1px solid #333;
    border-radius: 4px;
    padding: clamp(0.15rem, 0.5vmin, 0.3rem) clamp(0.4rem, 1.5vmin, 0.8rem);
    font-size: clamp(0.5rem, 1.8vmin, 0.8rem);
    color: #888;
    margin-bottom: clamp(0.3rem, 1vmin, 1rem);
  }
  .controls {
    margin-top: clamp(0.5rem, 1.5vmin, 1.5rem);
    display: flex;
    gap: clamp(0.4rem, 1.5vmin, 1rem);
    justify-content: center;
    flex-wrap: wrap;
  }
  button {
    background: #1a1a1a;
    color: #e0e0e0;
    border: 1px solid #333;
    padding: clamp(0.3rem, 1vmin, 0.6rem) clamp(0.6rem, 2.5vmin, 1.5rem);
    font-family: inherit;
    font-size: clamp(0.55rem, 2vmin, 0.9rem);
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s;
    touch-action: manipulation;
    -webkit-tap-highlight-color: transparent;
  }
  button:hover { background: #2a2a2a; border-color: #555; }
  button.primary { border-color: #22c55e; color: #22c55e; }
  button.primary:hover { background: #22c55e22; }
  button.danger { border-color: #ef4444; color: #ef4444; }
  button.danger:hover { background: #ef444422; }
  .setup {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: clamp(0.5rem, 2vmin, 1.5rem);
    width: 100%;
  }
  .setup h1 {
    font-size: clamp(1rem, 5vmin, 2rem);
    font-weight: 300;
    margin-bottom: clamp(0.3rem, 1vmin, 1rem);
  }
  .time-presets {
    display: flex;
    gap: clamp(0.3rem, 1vmin, 0.8rem);
    flex-wrap: wrap;
    justify-content: center;
  }
  .time-presets button {
    font-size: clamp(0.6rem, 2.5vmin, 1.1rem);
    padding: clamp(0.3rem, 1.5vmin, 0.8rem) clamp(0.5rem, 2.5vmin, 1.5rem);
  }
  input[type="text"] {
    background: #1a1a1a;
    border: 1px solid #333;
    color: #e0e0e0;
    padding: clamp(0.3rem, 1vmin, 0.6rem) clamp(0.5rem, 1.5vmin, 1rem);
    font-family: inherit;
    font-size: clamp(0.6rem, 2.5vmin, 1rem);
    border-radius: 4px;
    width: min(300px, 90%);
    text-align: center;
  }
  input[type="text"]::placeholder { color: #444; }
  .checkins {
    margin-top: clamp(0.3rem, 1vmin, 1rem);
    font-size: clamp(0.5rem, 1.8vmin, 0.85rem);
    color: #555;
  }
  .checkins span.hit { color: #22c55e; text-decoration: line-through; }
  .checkins span.next { color: #f59e0b; }
  .sync-dot {
    display: inline-block;
    width: clamp(5px, 1vmin, 8px);
    height: clamp(5px, 1vmin, 8px);
    border-radius: 50%;
    margin-right: 0.4em;
    vertical-align: middle;
  }
  .sync-dot.connected { background: #22c55e; }
  .sync-dot.disconnected { background: #ef4444; }
  .sync-dot.polling { background: #f59e0b; animation: pulse 1s infinite; }
  .sync-status {
    position: fixed;
    top: clamp(0.3rem, 1vmin, 1rem);
    right: clamp(0.3rem, 1vmin, 1rem);
    font-size: clamp(0.4rem, 1.5vmin, 0.7rem);
    color: #444;
    z-index: 10;
  }
  .no-youtube {
    position: fixed;
    bottom: clamp(0.5rem, 1.5vmin, 1.5rem);
    right: clamp(0.5rem, 1.5vmin, 1.5rem);
    font-size: clamp(0.4rem, 1.5vmin, 0.75rem);
    color: #333;
    letter-spacing: 0.1em;
  }
  .waiting-screen { text-align: center; }
  .waiting-screen h1 {
    font-size: clamp(1rem, 5vmin, 2rem);
    font-weight: 300;
    margin-bottom: clamp(0.3rem, 1vmin, 1rem);
  }
  .waiting-screen p {
    color: #555;
    font-size: clamp(0.55rem, 2vmin, 0.9rem);
  }
  .waiting-pulse {
    font-size: clamp(1.5rem, 8vmin, 4rem);
    color: #333;
    animation: pulse 2s infinite;
    margin: clamp(0.5rem, 2vmin, 2rem) 0;
  }

  /* Hamster wheel */
  .hamster-scene {
    margin: clamp(0.3rem, 1.5vmin, 1rem) 0;
    position: relative;
    width: clamp(80px, 22vmin, 180px);
    height: clamp(80px, 22vmin, 180px);
  }
  .hamster-scene canvas {
    width: 100%;
    height: 100%;
  }
  .hamster-scene.done canvas {
    filter: hue-rotate(90deg) brightness(1.3);
  }
  .speed-label {
    font-size: clamp(0.4rem, 1.3vmin, 0.65rem);
    color: #444;
    margin-top: clamp(0.1rem, 0.3vmin, 0.3rem);
    letter-spacing: 0.15em;
    text-transform: uppercase;
  }

  /* Ultra-compact */
  @media (max-height: 350px) {
    .header, .task, .sprint-label { display: none; }
    .no-youtube { display: none; }
    .progress-bar { margin: 0.2rem 0; }
    .controls { margin-top: 0.3rem; }
    .hamster-scene { width: 60px; height: 60px; }
  }
  @media (max-height: 250px) {
    .checkins, .status, .speed-label { display: none; }
    .progress-bar { display: none; }
  }
  @media (max-height: 180px) {
    .hamster-scene { display: none; }
  }
  @media (max-width: 200px) {
    .controls { flex-direction: column; }
    .time-presets { flex-direction: column; }
    .no-youtube { display: none; }
  }
</style>
</head>
<body>

<div class="sync-status">
  <span class="sync-dot polling" id="sync-dot"></span>
  <span id="sync-text">connecting...</span>
</div>

<div class="container" id="setup-screen">
  <div class="setup">
    <h1>üê±‚ö° Sprint Timer</h1>
    <input type="text" id="task-input" placeholder="What are you working on?">
    <div class="time-presets">
      <button onclick="startTimer(15)">15 min</button>
      <button onclick="startTimer(25)">25 min</button>
      <button onclick="startTimer(50)" class="primary">50 min</button>
      <button onclick="startTimer(75)">75 min</button>
      <button onclick="startTimer(90)">90 min</button>
    </div>
    <p style="color:#555; font-size:clamp(0.45rem,1.5vmin,0.8rem); margin-top:clamp(0.3rem,1vmin,1rem);">or wait for Ford to start a session ‚Üë</p>
  </div>
</div>

<div class="container" id="waiting-screen" style="display:none;">
  <div class="waiting-screen">
    <h1>üê±‚ö° Sprint Timer</h1>
    <div class="waiting-pulse">‚è≥</div>
    <p>Waiting for Ford to start a session...</p>
    <p style="margin-top:0.5rem; color:#444; font-size:clamp(0.45rem,1.5vmin,0.8rem);">Polling every 5 seconds</p>
    <div class="controls" style="margin-top:clamp(0.5rem,2vmin,2rem);">
      <button onclick="showSetup()">Start manually instead</button>
    </div>
  </div>
</div>

<div class="container" id="timer-screen" style="display:none;">
  <div class="sprint-label" id="sprint-label">SPRINT</div>
  <div class="header">BODY DOUBLING</div>
  <div class="task" id="task-display"></div>
  <div class="hamster-scene" id="hamster-scene">
    <canvas id="hamster-canvas" width="180" height="180"></canvas>
  </div>
  <div class="speed-label" id="speed-label">üêπ chill jog</div>
  <div class="clock running" id="clock">50:00</div>
  <div class="progress-bar"><div class="progress-fill" id="progress" style="width:0%"></div></div>
  <div class="checkins" id="checkins"></div>
  <div class="status" id="status">focused.</div>
  <div class="controls">
    <button onclick="pauseResume()" id="pause-btn">‚è∏ Pause</button>
    <button onclick="resetTimer()" class="danger">‚úï End</button>
  </div>
</div>

<div class="no-youtube">no youtube.</div>

<script>
// === HAMSTER WHEEL ANIMATION ===
const hamsterCanvas = document.getElementById('hamster-canvas');
const hctx = hamsterCanvas.getContext('2d');
let wheelAngle = 0;
let hamsterSpeed = 0.5; // radians per second ‚Äî starts chill
let hamsterLegPhase = 0;
let hamsterAnimFrame = null;
let lastHamsterTime = 0;
let hamsterDone = false;
let hamsterSweat = [];

function resizeHamsterCanvas() {
  const scene = document.getElementById('hamster-scene');
  const size = scene.clientWidth;
  hamsterCanvas.width = size * 2; // retina
  hamsterCanvas.height = size * 2;
  hamsterCanvas.style.width = size + 'px';
  hamsterCanvas.style.height = size + 'px';
}

function drawHamsterWheel(timestamp) {
  if (!lastHamsterTime) lastHamsterTime = timestamp;
  const dt = (timestamp - lastHamsterTime) / 1000;
  lastHamsterTime = timestamp;

  const w = hamsterCanvas.width;
  const h = hamsterCanvas.height;
  const cx = w / 2;
  const cy = h / 2;
  const radius = w * 0.38;

  hctx.clearRect(0, 0, w, h);

  if (!hamsterDone) {
    wheelAngle += hamsterSpeed * dt;
    hamsterLegPhase += hamsterSpeed * dt * 3;
  }

  // Wheel
  hctx.save();
  hctx.translate(cx, cy);
  hctx.rotate(wheelAngle);

  // Outer ring
  hctx.beginPath();
  hctx.arc(0, 0, radius, 0, Math.PI * 2);
  hctx.strokeStyle = getWheelColor();
  hctx.lineWidth = w * 0.015;
  hctx.stroke();

  // Spokes
  const spokeCount = 8;
  for (let i = 0; i < spokeCount; i++) {
    const angle = (i / spokeCount) * Math.PI * 2;
    hctx.beginPath();
    hctx.moveTo(0, 0);
    hctx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
    hctx.strokeStyle = getWheelColor() + '66';
    hctx.lineWidth = w * 0.008;
    hctx.stroke();
  }

  // Inner ring
  hctx.beginPath();
  hctx.arc(0, 0, radius * 0.15, 0, Math.PI * 2);
  hctx.strokeStyle = getWheelColor() + '88';
  hctx.lineWidth = w * 0.01;
  hctx.stroke();

  hctx.restore();

  // Hamster body (sits at bottom of wheel, doesn't rotate)
  const hamX = cx;
  const hamY = cy + radius * 0.35;
  const hamSize = radius * 0.35;

  if (hamsterDone) {
    drawHamsterCelebrating(hamX, hamY, hamSize, timestamp);
  } else {
    drawHamsterRunning(hamX, hamY, hamSize);
  }

  // Sweat particles when speed > 3
  if (hamsterSpeed > 3 && !hamsterDone) {
    if (Math.random() < 0.3) {
      hamsterSweat.push({
        x: hamX + (Math.random() - 0.5) * hamSize,
        y: hamY - hamSize * 0.8,
        vx: (Math.random() - 0.5) * 2,
        vy: -Math.random() * 3 - 1,
        life: 1
      });
    }
  }

  // Update and draw sweat
  hamsterSweat = hamsterSweat.filter(s => {
    s.x += s.vx;
    s.y += s.vy;
    s.life -= dt * 2;
    if (s.life <= 0) return false;
    hctx.beginPath();
    hctx.arc(s.x, s.y, w * 0.012, 0, Math.PI * 2);
    hctx.fillStyle = `rgba(100, 180, 255, ${s.life * 0.6})`;
    hctx.fill();
    return true;
  });

  hamsterAnimFrame = requestAnimationFrame(drawHamsterWheel);
}

function drawHamsterRunning(x, y, size) {
  const legOffset = Math.sin(hamsterLegPhase) * size * 0.3;
  const legOffset2 = Math.sin(hamsterLegPhase + Math.PI) * size * 0.3;
  const bodyBob = Math.abs(Math.sin(hamsterLegPhase * 0.5)) * size * 0.08;

  // Body
  hctx.beginPath();
  hctx.ellipse(x, y - bodyBob, size * 0.9, size * 0.65, 0, 0, Math.PI * 2);
  hctx.fillStyle = '#c08040';
  hctx.fill();

  // Belly
  hctx.beginPath();
  hctx.ellipse(x, y - bodyBob + size * 0.15, size * 0.55, size * 0.4, 0, 0, Math.PI * 2);
  hctx.fillStyle = '#e0b878';
  hctx.fill();

  // Head
  hctx.beginPath();
  hctx.arc(x + size * 0.65, y - size * 0.3 - bodyBob, size * 0.45, 0, Math.PI * 2);
  hctx.fillStyle = '#c08040';
  hctx.fill();

  // Ear
  hctx.beginPath();
  hctx.arc(x + size * 0.85, y - size * 0.65 - bodyBob, size * 0.18, 0, Math.PI * 2);
  hctx.fillStyle = '#d09050';
  hctx.fill();
  hctx.beginPath();
  hctx.arc(x + size * 0.85, y - size * 0.65 - bodyBob, size * 0.1, 0, Math.PI * 2);
  hctx.fillStyle = '#e8a0a0';
  hctx.fill();

  // Eye
  hctx.beginPath();
  hctx.arc(x + size * 0.85, y - size * 0.35 - bodyBob, size * 0.09, 0, Math.PI * 2);
  hctx.fillStyle = '#111';
  hctx.fill();
  // Eye glint
  hctx.beginPath();
  hctx.arc(x + size * 0.88, y - size * 0.38 - bodyBob, size * 0.03, 0, Math.PI * 2);
  hctx.fillStyle = '#fff';
  hctx.fill();

  // Nose
  hctx.beginPath();
  hctx.arc(x + size * 1.05, y - size * 0.2 - bodyBob, size * 0.06, 0, Math.PI * 2);
  hctx.fillStyle = '#ff9090';
  hctx.fill();

  // Cheek pouches when speed is high (puffed with effort)
  if (hamsterSpeed > 2) {
    hctx.beginPath();
    hctx.arc(x + size * 0.75, y - size * 0.05 - bodyBob, size * 0.2, 0, Math.PI * 2);
    hctx.fillStyle = '#d09858';
    hctx.fill();
  }

  // Front legs
  hctx.strokeStyle = '#b07030';
  hctx.lineWidth = size * 0.15;
  hctx.lineCap = 'round';

  hctx.beginPath();
  hctx.moveTo(x + size * 0.3, y + size * 0.35);
  hctx.lineTo(x + size * 0.3 + legOffset * 0.5, y + size * 0.7);
  hctx.stroke();

  hctx.beginPath();
  hctx.moveTo(x + size * 0.1, y + size * 0.35);
  hctx.lineTo(x + size * 0.1 + legOffset2 * 0.5, y + size * 0.7);
  hctx.stroke();

  // Back legs
  hctx.beginPath();
  hctx.moveTo(x - size * 0.4, y + size * 0.3);
  hctx.lineTo(x - size * 0.4 + legOffset, y + size * 0.7);
  hctx.stroke();

  hctx.beginPath();
  hctx.moveTo(x - size * 0.6, y + size * 0.3);
  hctx.lineTo(x - size * 0.6 + legOffset2, y + size * 0.7);
  hctx.stroke();

  // Tail
  hctx.beginPath();
  hctx.moveTo(x - size * 0.85, y - size * 0.1 - bodyBob);
  hctx.quadraticCurveTo(x - size * 1.1, y - size * 0.5 - bodyBob, x - size * 0.9, y - size * 0.6 - bodyBob);
  hctx.strokeStyle = '#b07030';
  hctx.lineWidth = size * 0.08;
  hctx.stroke();
}

function drawHamsterCelebrating(x, y, size, t) {
  const bounce = Math.abs(Math.sin(t / 200)) * size * 0.3;

  // Body
  hctx.beginPath();
  hctx.ellipse(x, y - bounce, size * 0.9, size * 0.65, 0, 0, Math.PI * 2);
  hctx.fillStyle = '#c08040';
  hctx.fill();

  // Belly
  hctx.beginPath();
  hctx.ellipse(x, y - bounce + size * 0.15, size * 0.55, size * 0.4, 0, 0, Math.PI * 2);
  hctx.fillStyle = '#e0b878';
  hctx.fill();

  // Head
  hctx.beginPath();
  hctx.arc(x + size * 0.65, y - size * 0.3 - bounce, size * 0.45, 0, Math.PI * 2);
  hctx.fillStyle = '#c08040';
  hctx.fill();

  // Ears
  hctx.beginPath();
  hctx.arc(x + size * 0.85, y - size * 0.65 - bounce, size * 0.18, 0, Math.PI * 2);
  hctx.fillStyle = '#d09050';
  hctx.fill();

  // Happy eyes (closed arcs)
  hctx.beginPath();
  hctx.arc(x + size * 0.85, y - size * 0.35 - bounce, size * 0.09, 0, Math.PI, true);
  hctx.strokeStyle = '#111';
  hctx.lineWidth = size * 0.04;
  hctx.stroke();

  // Arms up!
  hctx.strokeStyle = '#b07030';
  hctx.lineWidth = size * 0.15;
  hctx.lineCap = 'round';

  const armWave = Math.sin(t / 150) * 0.3;
  hctx.beginPath();
  hctx.moveTo(x + size * 0.3, y - size * 0.1 - bounce);
  hctx.lineTo(x + size * 0.5, y - size * 0.8 - bounce + armWave * size);
  hctx.stroke();

  hctx.beginPath();
  hctx.moveTo(x - size * 0.1, y - size * 0.1 - bounce);
  hctx.lineTo(x - size * 0.3, y - size * 0.8 - bounce - armWave * size);
  hctx.stroke();

  // Party text
  hctx.font = `${size * 0.4}px serif`;
  hctx.fillStyle = '#22c55e';
  hctx.textAlign = 'center';
  hctx.fillText('üéâ', x, y - size * 1.3 - bounce);
}

function getWheelColor() {
  if (hamsterDone) return '#22c55e';
  if (hamsterSpeed > 5) return '#ef4444';
  if (hamsterSpeed > 3) return '#f59e0b';
  return '#444';
}

function updateHamsterSpeed(pctElapsed) {
  // Exponential ramp: chill at start, frantic at end
  // pctElapsed: 0 to 1
  if (pctElapsed >= 1) {
    hamsterDone = true;
    hamsterSpeed = 0;
    document.getElementById('speed-label').textContent = 'üêπ üéâ DONE!';
    document.getElementById('hamster-scene').classList.add('done');
    return;
  }

  hamsterDone = false;
  document.getElementById('hamster-scene').classList.remove('done');

  // Speed curve: 0.5 at 0%, ramps to ~8 at 100%
  // Using exponential: speed = 0.5 * e^(2.8 * pct)
  hamsterSpeed = 0.5 * Math.exp(2.8 * pctElapsed);

  // Speed labels
  const label = document.getElementById('speed-label');
  if (pctElapsed < 0.2) label.textContent = 'üêπ chill jog';
  else if (pctElapsed < 0.4) label.textContent = 'üêπ warming up';
  else if (pctElapsed < 0.6) label.textContent = 'üêπ picking up pace';
  else if (pctElapsed < 0.75) label.textContent = 'üêπ running hard';
  else if (pctElapsed < 0.9) label.textContent = 'üêπüí¶ full sprint!';
  else label.textContent = 'üêπüî• MAXIMUM OVERDRIVE';
}

function startHamsterAnimation() {
  hamsterDone = false;
  hamsterSweat = [];
  lastHamsterTime = 0;
  resizeHamsterCanvas();
  if (hamsterAnimFrame) cancelAnimationFrame(hamsterAnimFrame);
  hamsterAnimFrame = requestAnimationFrame(drawHamsterWheel);
}

function stopHamsterAnimation() {
  if (hamsterAnimFrame) {
    cancelAnimationFrame(hamsterAnimFrame);
    hamsterAnimFrame = null;
  }
}

window.addEventListener('resize', () => {
  if (currentMode === 'timer') resizeHamsterCanvas();
});

// === TIMER LOGIC ===
const API_URL = 'https://yellow-block-6533.alexeyyoussef.workers.dev';
const API_KEY = new URLSearchParams(window.location.search).get('key') || '';
const POLL_INTERVAL = 5000;

let totalSeconds = 0;
let startedAtMs = 0;
let localInterval = null;
let paused = false;
let checkinTimes = [];
let syncMode = !!API_KEY;
let currentMode = 'setup';

function getCheckins(minutes) {
  if (minutes <= 15) return [10];
  if (minutes <= 25) return [15];
  if (minutes <= 50) return [15, 35];
  if (minutes <= 75) return [20, 45, 60];
  return Array.from({length: Math.floor(minutes/20)}, (_, i) => (i+1)*20).filter(t => t < minutes);
}

function formatTime(s) {
  if (s < 0) s = 0;
  const m = Math.floor(s / 60);
  const sec = s % 60;
  return `${String(m).padStart(2,'0')}:${String(sec).padStart(2,'0')}`;
}

function showScreen(name) {
  document.getElementById('setup-screen').style.display = name === 'setup' ? 'flex' : 'none';
  document.getElementById('waiting-screen').style.display = name === 'waiting' ? 'flex' : 'none';
  document.getElementById('timer-screen').style.display = name === 'timer' ? 'flex' : 'none';
  currentMode = name;
}

function showSetup() { showScreen('setup'); }

function startTimer(minutes, task, startMs, sprint) {
  totalSeconds = minutes * 60;
  startedAtMs = startMs || Date.now();
  checkinTimes = getCheckins(minutes);

  const taskText = task || document.getElementById('task-input').value || 'Deep work';
  document.getElementById('task-display').textContent = taskText;
  document.getElementById('sprint-label').textContent = sprint ? `SPRINT ${sprint} ¬∑ ${minutes} MIN` : `${minutes} MIN SPRINT`;

  showScreen('timer');
  paused = false;

  startHamsterAnimation();

  if (localInterval) clearInterval(localInterval);
  localInterval = setInterval(tick, 1000);
  tick();
}

function tick() {
  if (paused) return;

  const elapsedMs = Date.now() - startedAtMs;
  const elapsedSeconds = Math.floor(elapsedMs / 1000);
  const remainingSeconds = Math.max(0, totalSeconds - elapsedSeconds);
  const pctElapsed = Math.min(1, elapsedSeconds / totalSeconds);

  updateHamsterSpeed(pctElapsed);
  updateDisplay(remainingSeconds, elapsedSeconds);

  if (remainingSeconds <= 0) {
    clearInterval(localInterval);
    document.getElementById('status').textContent = '‚úÖ SESSION COMPLETE. Autopsy time.';
    document.getElementById('clock').className = 'clock done';
    document.title = '‚úÖ DONE';
  }
}

function updateDisplay(remainingSeconds, elapsedSeconds) {
  const elapsedMin = elapsedSeconds / 60;
  const pct = Math.min(100, (elapsedSeconds / totalSeconds) * 100);

  document.getElementById('clock').textContent = formatTime(remainingSeconds);
  document.getElementById('progress').style.width = pct + '%';
  document.title = `${formatTime(remainingSeconds)} ‚Äî Sprint`;

  const clock = document.getElementById('clock');
  if (remainingSeconds <= 0) {
    clock.className = 'clock done';
  } else if (remainingSeconds <= 60) {
    clock.className = 'clock danger';
  } else if (remainingSeconds <= 300) {
    clock.className = 'clock warning';
  } else {
    clock.className = 'clock running';
  }

  const checkinHtml = checkinTimes.map(t => {
    if (elapsedMin >= t) return `<span class="hit">‚úì ${t}min</span>`;
    const isNext = checkinTimes.filter(c => elapsedMin < c)[0] === t;
    if (isNext) return `<span class="next">‚Üí ${t}min check-in</span>`;
    return `<span>${t}min</span>`;
  }).join(' &nbsp;¬∑&nbsp; ');
  document.getElementById('checkins').innerHTML = checkinHtml;

  const statusEl = document.getElementById('status');
  if (remainingSeconds <= 0) statusEl.textContent = '‚úÖ session complete.';
  else if (remainingSeconds <= 60) statusEl.textContent = 'final minute. finish strong.';
  else if (remainingSeconds <= 300) statusEl.textContent = 'last 5 minutes. push.';
  else statusEl.textContent = 'focused.';
}

function pauseResume() {
  paused = !paused;
  document.getElementById('pause-btn').textContent = paused ? '‚ñ∂ Resume' : '‚è∏ Pause';
  document.getElementById('status').textContent = paused ? '‚è∏ paused.' : 'focused.';
}

function resetTimer() {
  clearInterval(localInterval);
  stopHamsterAnimation();
  if (syncMode) {
    showScreen('waiting');
  } else {
    showScreen('setup');
  }
  document.title = 'üê±‚ö° Sprint Timer';
}

// === SYNC MODE ===
let pollTimer = null;

async function pollState() {
  if (!syncMode) return;

  try {
    const dot = document.getElementById('sync-dot');
    const text = document.getElementById('sync-text');

    const res = await fetch(`${API_URL}/state?key=${API_KEY}`);
    if (!res.ok) {
      dot.className = 'sync-dot disconnected';
      text.textContent = 'auth failed';
      return;
    }

    const state = await res.json();
    dot.className = 'sync-dot connected';
    text.textContent = 'synced';

    if (state.active && currentMode !== 'timer') {
      startTimer(state.durationMin, state.task, state.startedAt, state.sprint);
    } else if (!state.active && currentMode === 'timer') {
      clearInterval(localInterval);
      updateHamsterSpeed(1); // trigger celebration
      document.getElementById('status').textContent = '‚úÖ SESSION ENDED BY FORD.';
      document.getElementById('clock').className = 'clock done';
      document.title = '‚úÖ DONE';
      setTimeout(() => { stopHamsterAnimation(); showScreen('waiting'); }, 5000);
    } else if (!state.active && currentMode === 'setup') {
      showScreen('waiting');
    }
  } catch (e) {
    document.getElementById('sync-dot').className = 'sync-dot disconnected';
    document.getElementById('sync-text').textContent = 'offline';
  }
}

// Init
const params = new URLSearchParams(window.location.search);

if (syncMode) {
  showScreen('waiting');
  pollState();
  pollTimer = setInterval(pollState, POLL_INTERVAL);
} else if (params.get('min')) {
  const startMs = params.get('start') ? parseInt(params.get('start')) : Date.now();
  startTimer(parseInt(params.get('min')), params.get('task') || '', startMs);
} else {
  showScreen('setup');
  document.getElementById('sync-dot').className = 'sync-dot disconnected';
  document.getElementById('sync-text').textContent = 'no key ‚Äî manual mode';
}
</script>
</body>
</html>
